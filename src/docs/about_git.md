## 2025-08-14

### 커밋이 옆으로 빠져나와 있을 때
#### pull (ff if possible) 했으나 ff가 안될 경우 옆으로 빠져나온 것을 합해 병합 커밋을 만들게 됨.
- ff가 안된 이유? 원격이랑 로컬에서의 커밋 상태가 달랐기 때문.
    - fast-forward는 포인터를 옮기는 작업
    - fast-forward가 가능하려면 내 브랜치가 원격 브랜치의 직계 조상이어야 함
    - 원격과 로컬에서 서로 다른 커밋이 있었으면 직계조상이 안되기때문에 ff가 안 된다.
#### rebase하면 선형화된다.
- 이때 rebase를 했다면 git은 로컬의 커밋을 따로 떼어내고(stash) 원격 커밋을 로컬에 가져온 다음, **이 위에** stash했던 로컬 커밋을 쌓는다.
- 그래서 linear가 이루어짐.
#### 그러나 이미 원격에 병합 커밋이 올라가 있는 경우, rebase한다음 **push --force**를 하는 것은 주의해야함
- 이미 원격에 병합 커밋이 올라가있는 경우 **이 위에** 내 커밋을 쌓게 되기 때문에 원격에 올라간 것이 삭제되고 새로운 히스토리로 덮어짐
- 이때는 그냥 push를 해보면 충돌 가능한지 보고 pull/rebase해서 해결 가능함

### 변경점을 stage하지 않고 pull받으면 stash기능을 적절히 이용할 수 있다는 말의 의미
> ###### 상황
> 1. draw io에서 뭘 수정한 다음 바로 github으로 저장을 함(remote에서 변경점이 잡힘)<br>
> 2. 이때 local에선 다른 java 파일변동이 이미 일어나있던 상태였는데 이걸 git에서 push나 commit하지 않은 상태<br>
> 3. draw io의 수정상황만 있는 상태에서 gitkraken에서 fetch를 했고<br>
> 4. draw io의 수정점이 git 노드로 왔는데 선형적이지 않고, 옆으로 뻗어나간 노드로 나타났음.<br>
> 5. 그런데 이 상황에서 pull, ff only 로 했더니 stash 어쩌고 하는 안내가 뜨더니<br>
> 6. 방금 draw io에서 했던 부분이 선형적 노드로 바뀜
- 2번에서 로컬 변경이 있었는데 이처럼 unstage, uncommitted 인 로컬 변경이 있으면
- git pull --ff-only를 할 수 없기에 stash를 권장하게 됨(5번 상황)
- stash로 인해 2번의 로컬 변경점이 임시 저장된 상태에서 원격 커밋을 가져오고,
- 그 이후 stash pop되므로 충돌없이 작업이 됨.